"use strict";(self.webpackChunkknot_docs=self.webpackChunkknot_docs||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Overview","href":"/docs/overview","docId":"overview"},{"type":"category","label":"Syntax","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Anatomy","href":"/docs/syntax/anatomy","docId":"syntax/anatomy"},{"type":"category","label":"Primitives","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Nil","href":"/docs/syntax/primitive/nil","docId":"syntax/primitive/nil"},{"type":"link","label":"Boolean","href":"/docs/syntax/primitive/boolean","docId":"syntax/primitive/boolean"},{"type":"link","label":"Number","href":"/docs/syntax/primitive/number","docId":"syntax/primitive/number"},{"type":"link","label":"String","href":"/docs/syntax/primitive/string","docId":"syntax/primitive/string"}],"href":"/docs/syntax/primitive/"},{"type":"link","label":"Types","href":"/docs/syntax/type","docId":"syntax/type"},{"type":"link","label":"Variables","href":"/docs/syntax/variable","docId":"syntax/variable"},{"type":"link","label":"Elements","href":"/docs/syntax/element","docId":"syntax/element"},{"type":"category","label":"Expressions","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Identifiers","href":"/docs/syntax/expression/identifier","docId":"syntax/expression/identifier"},{"type":"link","label":"Groups","href":"/docs/syntax/expression/group","docId":"syntax/expression/group"},{"type":"link","label":"Closures","href":"/docs/syntax/expression/closure","docId":"syntax/expression/closure"},{"type":"link","label":"Property Access","href":"/docs/syntax/expression/property-access","docId":"syntax/expression/property-access"},{"type":"link","label":"Function Call","href":"/docs/syntax/expression/function-call","docId":"syntax/expression/function-call"}],"href":"/docs/syntax/expression/"},{"type":"category","label":"Operators","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Comparison","href":"/docs/syntax/operator/comparison","docId":"syntax/operator/comparison"},{"type":"link","label":"Logical","href":"/docs/syntax/operator/logical","docId":"syntax/operator/logical"},{"type":"link","label":"Relational","href":"/docs/syntax/operator/relational","docId":"syntax/operator/relational"},{"type":"link","label":"Arithmetic","href":"/docs/syntax/operator/arithmetic","docId":"syntax/operator/arithmetic"}],"href":"/docs/syntax/operator/"},{"type":"category","label":"Statements","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Let Bindings","href":"/docs/syntax/statement/let-binding","docId":"syntax/statement/let-binding"}],"href":"/docs/syntax/statement/"},{"type":"category","label":"Declarations","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Constants","href":"/docs/syntax/declaration/constant","docId":"syntax/declaration/constant"},{"type":"link","label":"Functions","href":"/docs/syntax/declaration/function","docId":"syntax/declaration/function"},{"type":"link","label":"Views","href":"/docs/syntax/declaration/view","docId":"syntax/declaration/view"},{"type":"link","label":"Enumerated Types","href":"/docs/syntax/declaration/enum","docId":"syntax/declaration/enum"}],"href":"/docs/syntax/declaration/"},{"type":"category","label":"Modules","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Imports & Exports","href":"/docs/syntax/module/import-export","docId":"syntax/module/import-export"}],"href":"/docs/syntax/module/"}],"href":"/docs/syntax/"}]},"docs":{"overview":{"id":"overview","title":"Overview","description":"The Knot Language is made up of a number of different layers.","sidebar":"tutorialSidebar"},"syntax/anatomy":{"id":"syntax/anatomy","title":"Anatomy","description":"A Knot program is built out of the following constructs:","sidebar":"tutorialSidebar"},"syntax/declaration/constant":{"id":"syntax/declaration/constant","title":"Constants","description":"Constants are variables that cannot be mutated after their declaration, they are scoped to the module level","sidebar":"tutorialSidebar"},"syntax/declaration/enum":{"id":"syntax/declaration/enum","title":"Enumerated Types","description":"When modeling state machines it can be useful to describe variants of a single type that can contain different values.","sidebar":"tutorialSidebar"},"syntax/declaration/function":{"id":"syntax/declaration/function","title":"Functions","description":"Use functions to modularize shared logic such as data extraction and generation.","sidebar":"tutorialSidebar"},"syntax/declaration/index":{"id":"syntax/declaration/index","title":"Declarations","description":"All declarations in a module are available for import from within other modules.","sidebar":"tutorialSidebar"},"syntax/declaration/view":{"id":"syntax/declaration/view","title":"Views","description":"An entity that accepts a collection of properties and returns an element.","sidebar":"tutorialSidebar"},"syntax/element":{"id":"syntax/element","title":"Elements","description":"This expression is used to describe an element in the application\'s render tree.","sidebar":"tutorialSidebar"},"syntax/expression/closure":{"id":"syntax/expression/closure","title":"Closures","description":"If you need more complex logic to initialize your variables you might want to reach for a closure expression.","sidebar":"tutorialSidebar"},"syntax/expression/function-call":{"id":"syntax/expression/function-call","title":"Function Call","description":"Use this syntax to invoke a function and retrieve its result.","sidebar":"tutorialSidebar"},"syntax/expression/group":{"id":"syntax/expression/group","title":"Groups","description":"If you need to overcome the operator priority you can use groups to represent your intended logical groupings.","sidebar":"tutorialSidebar"},"syntax/expression/identifier":{"id":"syntax/expression/identifier","title":"Identifiers","description":"Variables created with a const or let bindings can be referenced by name.","sidebar":"tutorialSidebar"},"syntax/expression/index":{"id":"syntax/expression/index","title":"Expressions","description":"In addition to the basic primitives this language also has some additional expression syntax.","sidebar":"tutorialSidebar"},"syntax/expression/property-access":{"id":"syntax/expression/property-access","title":"Property Access","description":"When dealing with objects you may need to access their properties which can be done with the . operator.","sidebar":"tutorialSidebar"},"syntax/index":{"id":"syntax/index","title":"Syntax","description":"This is what the language looks like.","sidebar":"tutorialSidebar"},"syntax/module/import-export":{"id":"syntax/module/import-export","title":"Imports & Exports","description":"Imports should appear at the top of the module as at some point it will be enforced by the compiler","sidebar":"tutorialSidebar"},"syntax/module/index":{"id":"syntax/module/index","title":"Modules","description":"Modules represent the largest shareable and reusable code element.","sidebar":"tutorialSidebar"},"syntax/operator/arithmetic":{"id":"syntax/operator/arithmetic","title":"Arithmetic","description":"These operations perform basic arithmetic (add, subtract, divide, etc.) on numeric types","sidebar":"tutorialSidebar"},"syntax/operator/comparison":{"id":"syntax/operator/comparison","title":"Comparison","description":"Used to compare values of all types with each other.","sidebar":"tutorialSidebar"},"syntax/operator/index":{"id":"syntax/operator/index","title":"Operators","description":"These are symbols that are built in to the language and can be used to perform","sidebar":"tutorialSidebar"},"syntax/operator/logical":{"id":"syntax/operator/logical","title":"Logical","description":"These operations can be performed on boolean values.","sidebar":"tutorialSidebar"},"syntax/operator/relational":{"id":"syntax/operator/relational","title":"Relational","description":"These operations are used to compare numeric (integer and float) values.","sidebar":"tutorialSidebar"},"syntax/primitive/boolean":{"id":"syntax/primitive/boolean","title":"Boolean","description":"The second simplest primitive of the language; its value can only be true or false.","sidebar":"tutorialSidebar"},"syntax/primitive/index":{"id":"syntax/primitive/index","title":"Primitives","description":"Primitive data types are used to describe the smallest elements of data in an program.","sidebar":"tutorialSidebar"},"syntax/primitive/nil":{"id":"syntax/primitive/nil","title":"Nil","description":"Sometimes you need to explicitly not return a value, this is when to use nil.","sidebar":"tutorialSidebar"},"syntax/primitive/number":{"id":"syntax/primitive/number","title":"Number","description":"Integer","sidebar":"tutorialSidebar"},"syntax/primitive/string":{"id":"syntax/primitive/string","title":"String","description":"Textual data can be represented using string primitives.","sidebar":"tutorialSidebar"},"syntax/statement/index":{"id":"syntax/statement/index","title":"Statements","description":"Closures in Knot can be empty or contain one or more statements.","sidebar":"tutorialSidebar"},"syntax/statement/let-binding":{"id":"syntax/statement/let-binding","title":"Let Bindings","description":"You can use the let keyword to bind a value to some name so it can be referenced withing a closure.","sidebar":"tutorialSidebar"},"syntax/type":{"id":"syntax/type","title":"Types","description":"There are 6 built-in types that can be combined in type expressions to describe more complex types.","sidebar":"tutorialSidebar"},"syntax/variable":{"id":"syntax/variable","title":"Variables","description":"Reference data by storing it in a variable; it\'s the way of the future!","sidebar":"tutorialSidebar"}}}')}}]);